---
title: Java学习笔记一
date: 2019-09-11 22:46:37
tags:
    - Notes
    - Java
categories: 
    - [Java]
    - [Notes]
---

主要记录《Java核心技术》中类、继承与接口内容中的易混淆的知识点，方便以后整理记忆。本文主要记录复习之中遇到的基础知识，基础好的可以当复习材料来看~
update：添加关于程序中异常处理操作的知识点
<!--more-->


## 关于权限限制符protected的理解
最近看书时遇到了关于权限修饰符protected的问题，之前对于protected修饰符没有想太多，因此需要记录一下。


## equals和==的区别
- equals方法是检测两个字符串是否相等
- ==只能够确定两个字符串是否在同一位置，如果放置在同一位置就必然相等


## String、StringBuffer和StringBuilder有什么区别

- String是Java中重要而且基础的类，String类的对象是不可变的字符串，无法修改字符串中的字符，只能通过拼接修改，会创建一个新的对象。

- StringBuffer就是为了解决大量拼接字符而产生许多中间问题而提供的一个类。它的本质是一个线程安全的可修改的字符序列。但保证了线程安全就会需要鑫能的代价.是一个可变的字符串类，可以看作一个容器。

- StringBuilder就是可以让字符串任意拼接而不需要线程安全。


## 数组与数组列表的区别

在Java中，对象数组即是一个由对象的引用构成的数组，并非所有对象的本身组成的数组。

- 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配 100 个元素的存储空间，数组就只有 100 个空位置可以使用。超过容量就会出现数组越界的错误。

- 容量为 100 个元素的数组列表只是拥 有保存 100 个元素的潜力（实际上，重新分配空间的话，将可以超过100个元素）


## 对象包装器与自动拆、装箱

有时需要将int这样的基本数据类型转为对象。所有的基本类型都有一个与之相关的类，例如，Integer类就对应着int基本类型。这些类就被称为**包装类**。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类Number)。

加入想定义一个整型数组列表，而尖括号内的类型变量不允许是基本类型，即不允许写成`ArrayList<int>`,这时候我们就需要实例化为引用类型，即使用对象包装器。则整型数组列表就可以写成：
```java
    ArrayList<Integer> list = new ArrayList();
```

我们在使用包装类时处理语句、方法的参数或逻辑表达式时，Java会自动在引用类型和对应的基本类型数据之间进行转换。在这里，这种转换有助于我们同时使用泛型和原始数据类型。
例如：
 `list.add(3)`会自动地变换为`list.add(Integer.valueof(3))`
这种变换就被成为自动装箱。

相反的，当将一个Integer对象赋予一个int值时，将会自动拆箱。也就是说，编译器将下列语句：
```java
    int n = list.get(i)
```
翻译成：
```java
    int n = list.get(i).intValue();
```
> 最后强调一下，装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类地字节码时，插入必要地方法调用。虚拟机只是执行这些字节码。
> 
## Java接口
Java中接口是为了描述类具有什么功能，而不给出每个类的具体实现。接口不是类，而是对类的一种需求描述，对于实现接口的类就可以创建实现特定功能的对象。
可以把接口看作没有实例域的抽象类，但是这两个还是有一定的区别的
![Java接口思维导图](https://i.loli.net/2019/10/08/gxp1cKNkjzR5XfQ.png)

应当优先使用接口而不是实现接口的类来引用对象，但是只有存在合适的接口类型时。
也就是说，使用接口类去引用对象是有前提条件的——即实现类中全是接口类的方法的实现，没有自己单独的方法。当实现类存在自己的方法时，使用实现类来声明变量。

