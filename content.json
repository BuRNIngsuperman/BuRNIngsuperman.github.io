{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"深入理解Java内存模型","text":"Java虚拟机中定义了一种Java内存模型(Java Memory Model, JMM)来屏蔽各种硬件和操作系统之间的内存访问差异，以实现让Java程序能够在各种平台下都能达到一致的内存访问效果，在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此会由于不同平台内存模型的差异，有可能导致程序在这一套平台运行完全正常，但是在另外一套平台上则会经常出错. Java内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此时的变量与Java变成之中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法变量，因为后者是线程私有的。 并发模型的实质Java内存模型围绕着并发过程中如何处理原子性、可见性和顺序性这三个特征来设计的。 原子性有Java内存模型来直接保证原子性的变量操作包括read、load、use、assign、store、write这六个动作，虽然存在这long和double的特例，但是基本上可以忽略不计，目前虚拟机基本上都对其实现了原子性。如果想要求更大范围的控制，lock和unlock也可以满足需求。尽管虚拟机未把lock和unlock的操作直接开放给用户，但是提供了更高级的字节码命令monitorenter和monitorexit来隐式地使用这两个操作，对应到Java代码中就是同步块—-synchronized关键字，因此在synchronized块之间操作具有原子性。 可见性可见性是指一个线程修改了一个变量的值后，其他线程会立即感知到这个值的修改。正如volatile类型的变量在修改之后会立即同步给主内存，在使用的时候会从主内存中重新读取，是依赖主内存为中介来保证多线程下变量的修改对其他线程的可见性。 除了volatile变量之外，synchronized和final也可以实现可见性。其中，synchronized关键字是通过unlock之前必须把变量同步回主内存来实现的，final则是在初始化之后就不会在更改，所以只要在初始化过程中没有把this指针传递出去也能保证对其他线程的可见性。 有序性有序性可以从不同的角度来看，单纯是单线程来看都是有序的，但是到了多线程就会和我们预想的不一样。可以这么说：如果在线程内部观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句讲的是“线程内表现为串行的语义”，后半句指的是指令重排序现象和主内存与工作内存之间同步存在延迟现象。 保证有序性的关键字有volatile和synchronized，volatile禁止了指令重排序，而synchronized则由“一个变量在同一时刻只能被一个线程对其进行lock操作”来保证。 总体来看，synchronized对三种特性都有支持，虽然简单，但是如果无控制的滥用对性能就会产生较大影响。 Java内存模型的概念主内存Java虚拟机规定所有的变量（不是程序中的变量，指定是线程共享的对象）都必须在主内存中产生，为了方便我们的理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。 工作内存java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介来进行传递。 主内存、工作内存和Java内存区域中的Java堆、虚拟机栈、方法区并不是一个层次上的内存划分。上文注释便于理解做的类比。 工作内存和主内存之间的交互物理机高速缓存和主内存之间的交互有协议，同样的，java内存中线程的工作内存和主内存的交互是由java虚拟机定义了如下的8种操作来完成的，每种操作必须是原子性的(double和long类型在某些平台有例外）。 java虚拟机中主内存和工作内存交互，就是一个变量如何从主内存传输到工作内存中，如何把修改后的变量从工作内存同步回主内存。 lock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量 unlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定 read(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用 load(载入):作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的) use(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作 assign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作 store(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用 write(写入):作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中 如果要把一个变量从主内存传输到工作内存，那就要顺序的执行read和load操作，如果要把一个变量从工作内存回写到主内存，就要顺序的执行store和write操作。对于普通变量，虚拟机只是要求顺序的执行，并没有要求连续的执行，所以如下也是正确的。对于两个线程，分别从主内存中读取变量a和b的值，并不一样要read a; load a; read b; load b; 也会出现如下执行顺序：read a; read b; load b; load a; (对于volatile修饰的变量会有一些其他规则,后边会详细列出)，对于这8中操作，虚拟机也规定了一系列规则，在执行这8中操作的时候必须遵循如下的规则： 不允许read和load、store和write操作之一单独出现，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况 不允许一个线程丢弃最近的assign操作，也就是不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存 不允许一个线程回写没有修改的变量到主内存，也就是如果线程工作内存中变量没有发生过任何assign操作，是不允许将该变量的值回写到主内存 变量只能在主内存中产生，不允许在工作内存中直接使用一个未被初始化的变量，也就是没有执行load或者assign操作。也就是说在执行use、store之前必须对相同的变量执行了load、assign操作 一个变量在同一时刻只能被一个线程对其进行lock操作，也就是说一个线程一旦对一个变量加锁后，在该线程没有释放掉锁之前，其他线程是不能对其加锁的，但是同一个线程对一个变量加锁后，可以继续加锁，同时在释放锁的时候释放锁次数必须和加锁次数相同。 对变量执行lock操作，就会清空工作空间该变量的值，执行引擎使用这个变量之前，需要重新load或者assign操作初始化变量的值 不允许对没有lock的变量执行unlock操作，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作 对一个变量执行unlock之前，必须先把变量同步回主内存中，也就是执行store和write操作 当然，最重要的还是如开始所说，这8个动作必须是原子的，不可分割的。 volatile修饰的变量的特殊规则关键字volatile可以说是java虚拟机中提供的最轻量级的同步机制。java内存模型对volatile专门定义了一些特殊的访问规则。这些规则有些晦涩拗口，先列出规则，然后用更加通俗易懂的语言来解释： 假定T表示一个线程，V和W分别表示两个volatile修饰的变量，那么在进行read、load、use、assign、store和write操作的时候需要满足如下规则： 只有当线程T对变量V执行的前一个动作是load，线程T对变量V才能执行use动作；同时只有当线程T对变量V执行的后一个动作是use的时候线程T对变量V才能执行load操作。所以，线程T对变量V的use动作和线程T对变量V的read、load动作相关联，必须是连续一起出现。也就是在线程T的工作内存中，每次使用变量V之前必须从主内存去重新获取最新的值，用于保证线程T能看得见其他线程对变量V的最新的修改后的值。 只有当线程T对变量V执行的前一个动作是assign的时候，线程T对变量V才能执行store动作；同时只有当线程T对变量V执行的后一个动作是store的时候，线程T对变量V才能执行assign动作。所以，线程T对变量V的assign操作和线程T对变量V的store、write动作相关联，必须一起连续出现。也即是在线程T的工作内存中，每次修改变量V之后必须立刻同步回主内存，用于保证线程T对变量V的修改能立刻被其他线程看到。 假定动作A是线程T对变量V实施的use或assign动作，动作F是和动作A相关联的load或store动作，动作P是和动作F相对应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，动作G是和动作B相关联的load或store动作，动作Q是和动作G相对应的对变量W的read或write动作。如果动作A先于B，那么P先于Q。也就是说在同一个线程内部，被volatile修饰的变量不会被指令重排序，保证代码的执行顺序和程序的顺序相同。 总结上面三条规则，前面两条可以概括为：volatile类型的变量保证对所有线程的可见性。第三条为：volatile类型的变量禁止指令重排序优化。 long和double变量的特殊规则Java内存模型要求对主内存和工作内存交换的八个动作是原子的，正如章节开头所讲，对long和double有一些特殊规则。八个动作中lock、unlock、read、load、use、assign、store、write对待32位的基本数据类型都是原子操作， 对待long和double这两个64位的数据，java虚拟机规范对java内存模型的规定中特别定义了一条相对宽松的规则：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，也就是允许虚拟机不保证对64位数据的read、load、store和write这4个动作的操作是原子的。这也就是我们常说的long和double的非原子性协定(Nonautomic Treatment of double and long Variables)。","link":"/2020/03/03/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"Java学习笔记一","text":"主要记录《Java核心技术》中类、继承与接口内容中的易混淆的知识点，方便以后整理记忆。本文主要记录复习之中遇到的基础知识，基础好的可以当复习材料来看~update：添加关于程序中异常处理操作的知识点 关于权限限制符protected的理解最近看书时遇到了关于权限修饰符protected的问题，之前对于protected修饰符没有想太多，因此需要记录一下。 equals和==的区别 equals方法是检测两个字符串是否相等 ==只能够确定两个字符串是否在同一位置，如果放置在同一位置就必然相等 String、StringBuffer和StringBuilder有什么区别 String是Java中重要而且基础的类，String类的对象是不可变的字符串，无法修改字符串中的字符，只能通过拼接修改，会创建一个新的对象。 StringBuffer就是为了解决大量拼接字符而产生许多中间问题而提供的一个类。它的本质是一个线程安全的可修改的字符序列。但保证了线程安全就会需要鑫能的代价.是一个可变的字符串类，可以看作一个容器。 StringBuilder就是可以让字符串任意拼接而不需要线程安全。 数组与数组列表的区别在Java中，对象数组即是一个由对象的引用构成的数组，并非所有对象的本身组成的数组。 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配 100 个元素的存储空间，数组就只有 100 个空位置可以使用。超过容量就会出现数组越界的错误。 容量为 100 个元素的数组列表只是拥 有保存 100 个元素的潜力（实际上，重新分配空间的话，将可以超过100个元素） 对象包装器与自动拆、装箱有时需要将int这样的基本数据类型转为对象。所有的基本类型都有一个与之相关的类，例如，Integer类就对应着int基本类型。这些类就被称为包装类。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类Number)。 加入想定义一个整型数组列表，而尖括号内的类型变量不允许是基本类型，即不允许写成ArrayList&lt;int&gt;,这时候我们就需要实例化为引用类型，即使用对象包装器。则整型数组列表就可以写成：1ArrayList&lt;Integer&gt; list = new ArrayList(); 我们在使用包装类时处理语句、方法的参数或逻辑表达式时，Java会自动在引用类型和对应的基本类型数据之间进行转换。在这里，这种转换有助于我们同时使用泛型和原始数据类型。例如： list.add(3)会自动地变换为list.add(Integer.valueof(3))这种变换就被成为自动装箱。 相反的，当将一个Integer对象赋予一个int值时，将会自动拆箱。也就是说，编译器将下列语句：1int n = list.get(i)翻译成：1int n = list.get(i).intValue(); 最后强调一下，装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类地字节码时，插入必要地方法调用。虚拟机只是执行这些字节码。 Java接口Java中接口是为了描述类具有什么功能，而不给出每个类的具体实现。接口不是类，而是对类的一种需求描述，对于实现接口的类就可以创建实现特定功能的对象。可以把接口看作没有实例域的抽象类，但是这两个还是有一定的区别的 应当优先使用接口而不是实现接口的类来引用对象，但是只有存在合适的接口类型时。也就是说，使用接口类去引用对象是有前提条件的——即实现类中全是接口类的方法的实现，没有自己单独的方法。当实现类存在自己的方法时，使用实现类来声明变量。","link":"/2019/09/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"title":"JSP就是这么简单（入门篇）","text":"什么是JSPJSP的全称是Java Server Pages,即Java服务器页面。JSP是基于程序的页面其特点是HTML和Java语言并存，JSP页面可以看作在html页面中嵌入Java代码 HTML的全称是Hyper Text Markup Language,是一种常见的前端静态页面语言。 静态与动态： 不用 和是否有“动感”混为一谈 是否随着时间、地点、用户操作的改变而改变 动态网页需要使用到服务端脚本语言（JSP） 为什么需要JSPJSP是为了简化Servelet的工作而出现的替代品，Servelet输出前端HTML页面,JSP就是为了替代Servelet输出HTML页面的。 要了解JSP的原理，我们需要先简单地了解Servelet和网络的工作原理，以在Tomcat开发为例。 常见的服务器架构BS： Browser Server CS：Client Server 页面状态码200： 一切正常 404： 资源不存在 300/301： 页面重定向 403： 权限不足（如果访问a目录，但是a目录设置不可见） 500：服务器内部错误（代码有误） 其他代码：需要积累 tomcat指定首页在项目/WEB-INF/web.xml中写入12345&lt;welcome-file-list&gt;​ &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;就会指定index.jsp为首页 虚拟路径与虚拟主机虚拟路径将web项目配置到webapps以外的目录： 方式一 conf/server.xml host标签中:12&lt;Context docBase=&quot; &quot; path=&quot; &quot; /&gt; docBase:实际路径 path: 虚拟路径（绝对路径、相对路径【相对于webapps】) 缺点：需要重启 方式二 conf/Catalina/localhost/新建项目名.xml 然后再中间写入方式一中语句。 如果写入Root.xml就可以不用访问项目名不需要重启 虚拟主机每一个主机在访问互联网中的域名时，会访问互联网中的域名解析器（DNS）根据域名-IP映射关系找到域名对应的IP地址进行访问。但是在访问互联网中的DNS之前，会首先访问本机的域名解析器，因此可以通过虚拟主机访问某个域名就访问到本机。 通过修改Tomat里面conf/sever.xml文件中Host标签：1234&lt;Host appBase=&quot;项目路径&quot; name=&quot;域名名称&quot;&gt;&lt;Context docBase=&quot;项目路径&quot; path=&quot;url路径虚拟路径&quot;&gt;&lt;/Host&gt;然后在Engine中默认defaultHost改为相应的www.test.com,最后在driver中host文件加入相应的域名-IP映射。然后就可以访问该域名进而访问到对应的主机。 将端口号改为80后就可以认为时默认端口，访问域名时就不用加端口号 流程：www.test.com -&gt; host找映射 -&gt; server.xml找Engine的defaultHost -&gt; 通过“/”映射到对应的项目地址","link":"/2019/12/01/Jsp%E4%B8%8ETomcat%E5%85%A5%E9%97%A8/"},{"title":"利用hexo框架搭建blog并部署","text":"前言使用Github pages服务进行搭建和部署博客的好处有： 1.全是静态文件，访问速度快2.免费方便，可以搭建一个自由的个人博客3.可以随意的绑定自己的域名4.数据安全可靠，基于Github的版本管理，可以随时恢复到历史版本5.博客可以轻松打包、转移、发布到其它平台 准备工作在一切开始之前，你必须已经： 有一个github账号 安装了node.js,npm，并了解其相关知识 安装了git for windows 搭建github博客创建仓库新建一个名称为 你的用户名.github.io的仓库，必须是你的用户名，其他名称无效，将来你的网站的访问地址就是https://你的用户名.github.io。由此可见，每个github用户最多只能创建一个这样可以使用域名访问的网站。 绑定域名当然不绑定域名的话也是可以的，可直接使用github提供的域名进行访问。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。地址：hexo官网 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项:很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行 准备工作需要通过npm包资源管理器来下载Hexo博客框架，但由于网络限制，下载速度会非常慢，所以可以通过安装Cnpm来提高下载速度$ npm install cnpm --registry=https://registry.npm.taobao.org 安装通过以下指令安装hexo框架：$ cnpm install -g hexo-cli 初始化在电脑的某个地方创建一个用来存放博客代码的地方，并在此文件夹中进行初始化：$ hexo inithexo会自动下载一些文件到这个目录并建立Hexo框架，我的目录结构如下:$ hexo g #生成$ hexo s #启动服务执行上述命令后，hexo会在public文件夹中自动生成相应的HTML文件：hexo s开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，第一次初始化时hexo已经帮我们初始化了主题。 修改主题由于默认的主题比较丑，hexo可以非常方便的为我们提供主题替换，个人博客使用的主题是：hexo-theme-icarus 首先下载这个主题git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus修改_config.yml中的theme: landscape改为theme: icarus,然后重新执行hexo g来生成静态文件。如果出现了一些莫名其妙的错误，可以先执行hexo clean来清理一些public文件夹中文件并重新生成部署。 上传到Github首先先安装插件$ npm install hexo-deployer-git --save然后再配置_config.yml中deploy内容：1234deploy: type: git repo: https://github.com/BuRNIngsuperman/BuRNIngsuperman.github.io.git branch: master注意各个属性自己更改相应的值。然后打开终端，执行hexo d来将代码提交。这时候我们打开网站的访问地址就是http://你的用户名.github.io ，就可以看到blog已经部署完成。 hexo博客通过管理和迁移由于hexo框架博客自带的上传到github上只有生成的public文件中的静态文件，因此在迁移到另外一台电脑时需要在Github上备份环境文件，这里可以借鉴一下hexo博客同步管理,实现多台电脑同步管理。 常用的hexo指令常见指令：1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","link":"/2019/04/25/hexobulidblog/"},{"title":"Java开发的自学之路","text":"自己总结的Java开发的自学之路，并且按着这个目标路程不断学习前进 一个好的Java工程师应当掌握以下技能： 扎实的JAVA 基础，Think in java上介绍的内容都能理解，做到这一步恭喜成为了程序员。 熟练使用主流框架，如：mybatis，spring 等。 研究过至少一种以web框架的源码，如spring mvc ，struts 等。 架构过或者参与过高并发系统设计，知道如何应对突发情况。 对自己所处的业务能够根据自己的知识维度，提出优化建议或者预测其风险点。 基础知识： 编程语言：Java Python C C++ 基本算法：排序，查找这类的算法和数据结构，多刷题 基本网络知识： TCP/IP HTTP/HTTPS 七层传播协议、字段组成及加密过程 基本的设计模式 基础知识在面试时帮助很大，需要自己夯实基础 工具方面 操作系统：Linux (Centos\\Ubuntu) 代码管理： SVN/Git 持续集成（CI/CD）：jenkins Java 的项目管理工具：Maven/Gradle 进阶框架应用层框架 ssh: spring + structs + hibernate(过时已经不怎么使用) ssm: spring + springmvc + mybatis spring boot 各种中间件 MQ 消息队列 RPC 通信框架 gRPC thrift dubbc springcloud elasticsearch 数据库 搜索引擎 数据库 SQL : MySQL NoSQL: Redis Memcached mongodb elasticsearch 架构方面分布式/微服务架构 spring cloud dubbo rpc通信框架 虚拟化/容器化技术 Docker 容器化 KBS kubernetes 关注源码/性能 JDK源码及部分设计思想 Spring源码 JVM 细节与排错 高并发/高可用","link":"/2019/08/31/java%E5%BC%80%E5%8F%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"},{"title":"Markdown语法总结","text":"什么是MarkdownMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通的文本内容具有一定的格式。Markdown的目标是实现【易读易写】。写这样一篇语法汇总，旨在可以直观呈现效果和对应的语法格式。你可以把它作为自己在使用 Markdown 初期时手头的参考资料，希望对你开始或者熟练使用 Markdown 能有所帮助。 Markdown使用语法总结标题代码：123456789# 一级标题## 二级标题### 三级标题#### 四级标题# 一级标题 ### 二级标题 ##### 三级标题 ####### 四级标题 #### 改变字体粗体：Markdown中，用一对*表示强调，被强调的文字以粗体显示。斜体：Markdown中，用一对表示斜体代码：1234*要改变字体为斜体的内容***要改变字体为粗体的内容*****要改变字体为斜体+粗体字的内容***~~删除文字~~显示效果： 要改变字体为斜体的内容要改变字体为粗体的内容要改变字体为斜体+粗体字的内容删除文字 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，同时需要在分隔线的上面空一行。代码：12--------******** 效果： 代码工具行内代码代码：1234`这是行间代码``This is inline code`在 Java 输出 Hello, world ：`System.out.print(&quot;Hello, World!&quot;);`在 Java 输出 Hello, world ：```System.out.print(&quot;Hello, World!&quot;);``` 效果： 这是行间代码This is inline code在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;);在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;); 多行代码 语法：方法一：只需要每行都缩进 4 个空格即可方法二：使用`框起来 示例一（方法一）： 12345// JQuery 的 Hello, world$(function(){alert(&quot;Hello, world!&quot;)}); 效果：12345// JQuery 的 Hello, world$(function(){alert(&quot;Hello, world!&quot;)}); 示例二（方法二）【/为转义字符忽略不计】： 1234// JQuery 的 Hello, world$(function(){alert(&quot;Hello, world!&quot;)}); 代码高亮在需要高亮的代码块的前一行及后一行使用三个反引号`，同时第一行反引号后面表面代码块所使用的语言。如下面一段代码： #include”iostream.h”using namespace std; in main(){ cout &lt;&lt; “Hello World”; // 输出 Hello World return 0;} 显示效果：1234567#include&lt;iostream&gt;using namespace std;in main(){ cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0;} 列表1.在Markdown的语法中，我们可以使用1.、2.表示有序列表，即数字+点，不过注意序号和后面文字必须得有空格。2.无序列表用“-”或者“”表示，同样的，-和和后年的文字间必须有空格。且通过按tab键可以实现列表的嵌套 无序列表代码：12345678- 这是无序列表- 这是无序列表 - 这是无序列表 - 这是无序列表- 这是无序列表- 这是无序列表* 这是无序列表* 这是无序列表效果： 这是无序列表 这是无序列表 这是无序列表 这是无序列表 这是无序列表 这是无序列表 这是无序列表 这是无序列表 有序列表代码:12341. 这是有序列表2. 这是有序列表3. 这是有序列表4. 这是有序列表效果： 这是有序列表 这是有序列表 这是有序列表 这是有序列表 备注： 两个列表之间不能相邻，否则会解释为嵌套的列表无序列表的项目符号可使用 ,+,- 效果是相同的。列表与后续内容之间需要一个空行隔开，即：列表是一个段落列表允许多层次嵌套可以在项目中包含段落，只需将段落前添加一个 tab 或 4 个空格区块标记：是指内容独占一块，需前后换行，不和其他标记共处一行的标记。段落：即是一段连续的文字，可包含、空格、换行、tab等字符。两个段落之间使用空行分隔。注意：换行不是分段的标识，空行才是. 引用Markdown中，用符号&gt;开启一行引用，如果文字有多行则用多个&gt;，同样地&gt;和文字间必须有空格。这里补充一点：在Markdown中，空格+空格+Enter为换行，而Enter为另起一段落，这在书写引用时是非常重要的 代码：123&gt; 这是引用 &gt; 换行请按`空格+空格+Enter` &gt; 这是引用效果： 这是引用换行请按空格+空格+Enter这是引用 大于号 和 文字必须有一个空格可以在每行之前加 &gt; ，也可以在段落之前加 1 个 &gt;引用内部可以使用其他 Markdown 标记 链接（链接网址/图片）链接网址代码：1[ 百度网址 ](https://www.baidu.com/)效果：百度网址 链接图片代码：12![天气预报]（http://cdn.heweather.com/cond_icon/309.png） 备注：括号一定要是英文字符哦！ 效果： 限制图片大小并居中1234许多 MarkDown 编辑器中直接按原图大小显示图片，造成版面凌乱。 如何让图片像简书中那样大小一致居中显示呢？使用该命令 &lt;img src=&quot;图片地址&quot; width=&quot;图片显示宽度&quot; height=&quot;显示高度&quot; alt=&quot;图片名称&quot;/&gt;设置图片大小，再用&lt;div align=center&gt;&lt;/div&gt;命令包裹达到居中效果。 代码：123&lt;div align=center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/bmiddle/88070423gw1ep30aw8an7g204d04gkgd.gif&quot; width=&quot;400&quot; height=&quot;400&quot; alt=&quot;亦菲表演机器猫&quot;/&gt;&lt;/div&gt;显示效果： Markdown和HTML的关系HTML 是一种发布的格式，Markdown 是一种书写的格式。Markdown 的格式语法只涵盖纯文本可以涵盖的范围。在 Markdown 中可直接使用 HTML 标签，但需要注意： 对于 HTML 区块元素――如 div、table、pre、p 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符(tab)或空格来缩进 HTML 的行内标签——如 span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用. 在 HTML 的区块标签中的 Markdown 标签是没有效果的","link":"/2019/04/28/learnMarkdown/"},{"title":"动态规划解决矩阵连乘问题","text":"动态规划的概念与分治法相似，动态规划问题都是将问题分解为规模逐渐减小的同类型的子问题。不同之处： 分治法往往子问题之间相互独立，不包含公共子问题 而动态规划分解得到的子问题很多都是重复的 所以应用动态规划的两个标识是： 最优子结构，即最优化问题可以化为相应的最优化子问题 重复子问题 动态规划问题的一般性解题步骤 找出最优解的性质，并刻画其最优解结构特征 递归地找出最优解(写出其动态规划方程) 计算出最优解的值，通常采用自底向上的方法 根据计算最优解时得到的信息，以递归的方式构造一个最优解 矩阵连乘问题(矩阵链乘法)问题的描述对于给定的n个矩阵，$M_1,M_2,\\dots,M_n$,其中矩阵$M_i$ 和$M_j$是可乘的，要求确定计算矩阵连乘积($M_1 M_2 \\dots M_n$)的计算次序，使得按照该次数计算矩阵连乘积时需要的乘法次数最少 示例如下： 问题分析对于矩阵链的连乘问题，我们首先需要确定最优解的结构并从中推出递归动态规划方程，我们用$A_{i,j}$表示$A_i,A_{i+1},\\dots,A_j$矩阵连乘的结果，对于最优化的最终结果，我们可以在最终连乘的上一步在$A_k$和$A_{k+1}$之间把矩阵链划开，则前缀$A_{i,k}$和后缀$A_{k+1,j}$是其子问题，同时也满足最优化问题，即是最优子结构。我们令$m[i,j]$为计算矩阵链$A_{i,j}$乘法次数的最小值,矩阵$A_i$的大小为$p_{i-1}\\times p_i$,可知$A_{i,k}$和$A_{k+1,j}$相乘的代价为$p_{i-1}p_k p_j$次标量乘法运算。则推导其递归求解方程为： $$ m[i,j] = \\begin{cases} 0 &amp; \\text{如果 i = j} \\\\ \\min_{i\\leq k &lt;j}\\lbrace{m[i,k]+m[k+1,j]+p_{i-1}p_k p_j}\\rbrace &amp; \\text{如果 i &lt; j} \\end{cases}$$ 这时候我们就可以通过递归方程来计算出最优解的代价，这里我们可以采用自底向上的动态规划方法或改进的动态规划方法即备忘录法来计算所需的最小代价，最后一般通过递归的方式来构造最优解的处理，即矩阵链乘时括号化的步骤。 代码实现(Java)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package algorithms.dynamic_plan;/** * 动态规划法和备忘录法解决矩阵连乘问题 * @author jqy * */public class MatrixChain { /* * array[i][j]表示Ai...Aj相乘最少计算次数 * s[i][j]=k,表示Ai...Aj这(j-i+1)个矩阵中最优子结构为Ai...Ak和A(k+1)...Aj * p[i]表示Ai的行数，p[i+1]表示Ai的列数 */ private int array[][]; private int p[]; private int s[][]; public MatrixChain(){ p=new int[]{2,4,5,5,3}; array=new int[4][4]; s=new int[4][4]; } public MatrixChain(int n,int []p){ this.p=new int[n+1]; this.array=new int[n][n]; this.s=new int[4][4]; for(int i=0;i&lt;p.length;i++) this.p[i]=p[i]; } /*********************方法一，动态规划**********************************/ public void martixChain(){ int n=array.length; for(int i=0;i&lt;n;i++) array[i][i]=0; for(int r=2;r&lt;=n;r++){ for(int i=0;i&lt;=n-r;i++){ int j=i+r-1; array[i][j]=array[i+1][j]+p[i]*p[i+1]*p[j+1]; s[i][j]=i; for(int k=i+1;k&lt;j;k++){ int t=array[i][k]+array[k+1][j]+p[i]*p[k+1]*p[j]; if(t&lt;array[i][j]){ array[i][j]=t; s[i][j]=k; } } } } } /* * 如果待求矩阵为：Ap...Aq,then a=0,b=q-p */ public void traceBack(int a,int b){ if(a&lt;b){ traceBack(a, s[a][b]); traceBack(s[a][b]+1, b); System.out.println(&quot;先把A&quot;+a+&quot;到A&quot;+s[a][b]+&quot;括起来，在把A&quot;+(s[a][b]+1)+ &quot;到A&quot;+b+&quot;括起来，然后把A&quot;+a+&quot;到A&quot;+b+&quot;括起来&quot;); } } /*********************方法二：备忘录方法*****************************/ public int memorizedMatrixChain(){ int n=array.length; for(int i=0;i&lt;n;i++){ for(int j=i;j&lt;n;j++) array[i][j]=0; } return lookUpChain(0,n-1); } public int lookUpChain(int a,int b){ if(array[a][b]!=0) return array[a][b]; if(a==b) return 0; array[a][b]=lookUpChain(a, a)+lookUpChain(a+1, b)+p[a]*p[a+1]*p[b+1]; s[a][b]=a; for(int k=a+1;k&lt;b;k++){ int t=lookUpChain(a, k)+lookUpChain(k+1, b)+p[a]*p[k+1]*p[b+1]; if(t&lt;array[a][b]){ array[a][b]=t; s[a][b]=k; } } return array[a][b]; } public static void main(String[] args) { MatrixChain strassen=new MatrixChain(); //strassen.martixChain(); strassen.memorizedMatrixChain(); strassen.traceBack(0, 3); }}","link":"/2019/10/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98/"},{"title":"深入理解Object","text":"object类是Java所有类的始祖，也就是它们的超类，在Java中所有的类都是由它拓展而来的。子类都会继承所有Object类的public方法。 前言首先我们先来看看Object类的结构 可以使用Object类型的变量来引用任何类型的对象 1Object obj = new Employee(&quot;Harry&quot;,50000) 当然，Object类型的变量只能作为对象各种值的通用持有者，想要对其中的内容进行具体的操作，需要对其进行强制的类型转换。 1Employee e = (Employee) obj 在Java中，只有基本类型不是变量，所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。 在Objct类中一般有以下三种方法需要我们理解，并且一般需要重写。 equals方法123public boolean equals(Object obj) { return (this == obj); } Object类的equals方法用于检测一个对象是否等于另一个对象。在Object类中，这个方法将判断两个类变量是否有相同的引用，如果两个对象有着相同的引用，则这两个变量一定相等。但对于大多数类来说这判断并没有什么意义，因此子类需要重写equals方法来获得更准确的相等信息。 Java语言要求equals方法具有以下特性： 自反性: 对于任何非空引用x,x.equals(x)都是true。 对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，那么x.equals(y)也应该返回true。 传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。 一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回相同的结果 对于任何非空引用x,x.equals(null)都应该返回false。 所以等于相等性测试中继承问题，我么那就可从这两方面考虑： 如果子类能够拥有自己的相等概念，那么对称性需求将强制使用getClass方法进行检测 如果由超类决定相等的概念，那么就可以使用instanceof方法进行检测，这样可以在不同子类的对象之间进行相等的比较。 hashCode方法1public native int hashCode(); 散列码（hash code）是由对象导出的一个整形值。equals方法与hashCode方法必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值。 但是Object类中的HashCode()方法返回的hashcode值是与对象所在的内存地址绑定的，所以对于一些对象我们需要重写HashCode方法，让一些规则上相同但是内存地址不同的对象可以拥有相同的hashCode()方法返回的值。 如果重新定义eauals方法，那么就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。 toString方法123public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); } 返回一个String对象，一般子类会重写该方法以获得更准确的字符串表达。默认的返回格式为：对象的class名称+@+hashcode的十六进制字符。 clone方法1protected native Object clone() throws CloneNotSupportedException; 该方法实现的是对象的浅复制，只有实现了Cloneable接口的对象才能调用该方法，否则会抛出CloneNotSupportedException异常。 默认的clone方法只是浅拷贝，只能拷贝对象的引用地址，而不会重新分配内存再将要拷贝的对象复制过来。深拷贝则会把引用的对象本身也一起重新创建。 finalize方法1protected void finalize() throws Throwable { } 该方法为保护方法，主要用于在GC的时候被再次调用，如果我们实现了该方法，对象可能在这个方法中再次复活，从而避免了被GC回收。","link":"/2020/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Object/"},{"title":"深入理解HashMap","text":"最近为了准备面试看了一些面经，发现集合的问题问的比较多，尤其是HashMap的底层实现原理。之前学习集合的时候只知道怎么用HashMap，因此写了这篇博客记录一下关于集合类HashMap的底层原理及相关应用。 HashMap底层原理HashMap的底层数据结构在JDK1.8中是由数组、链表和红黑树实现的。它是基于Hash表的概念存储数据的。它是实现了集合的Map接口。 初始情况下，一般是由数组作为hash表中的桶(bin)，所有HashCode相同的键值会存放在同一个桶中，其中桶内的结构是采用链表结构。但是当桶内的结点个数大于预定的阈值8时，桶内的数据结构就会变为红黑树，这样会加快桶内数据的查询时间。 至于为什么阈值会设置为8就会有很多考虑，通常我们理解就是当结点阈值为8时，红黑树的查找时间复杂度为O(lg8) = o(3)，而链表的平均查找时间复杂度为O(8/2)=O(4)，这时使用红黑树会加快查询速度。 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 HashMap的put()的方法查看HashMap的源码，对put()方法进行分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断Hash中数组为空,就重新初始化数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据键的hash值利用散列表分配数组，如果数组为空则直接放入包含键值对的结点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; //根据key相等确定链表的头结点相等，就作替换 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 结构为红黑树就插入树中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { // 将Node插入合适的位置 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 步骤①：若哈希table为null，或长度为0，则做一次扩容操作；步骤②：根据index找到目标bucket后，若当前bucket上没有结点，那么直接新增一个结点，赋值给该bucket；步骤③：若当前bucket上有链表，且头结点就匹配，那么直接做替换即可；步骤④：若当前bucket上的是树结构，则转为红黑树的插入操作；步骤⑤：若步骤①、②、③、④都不成立，则对链表做遍历操作。 a) 若链表中有结点匹配，则做value替换； b）若没有结点匹配，则在链表末尾追加。同时，执行以下操作： i) 若链表长度大于TREEIFY_THRESHOLD，则执行红黑树转换操作； ii) 若条件i) 不成立，则执行扩容resize()操作。以上5步都执行完后，再看当前Map中存储的k-v对的数量是否超出了threshold，若超出，还需再次扩容。 根据key值找到散列表中的索引计算key的hash值1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 我们根据key的hashCode方法得出HashCode值作为输入得到hash值，这采取了一种高位运算的算法。 从以上知识点，我们可以得到一个推论：对于两个对象，若其hashCode相同，那么两个对象的hash值就一定相同。 一般情况下，HashCode的值是根据对象的内存地址得出来的。 这里还牵涉到另外一个知识点。对于HashMap中key的类型，必须满足以下的条件：若两个对象逻辑相等，那么他们的hashCode一定相等，反之却不一定成立。 例如对于String对象，它的HashCode实现就是根据内容来实现的。所以equals相等内容的对象HashCode值就相等。 取模操作我们根据key的hash值获得相应的数组索引操作是根据取模得出来的。取模操作是应用在put方法中 1(n - 1) &amp; hash //hash表长度与hash值做与运算 将HashMap的数组长度-1与hash值做与运算，这样做不仅效果和取模操作差不多，而且还大大提高了性能。 这里的操作也和为什么设置HashMap的长度为2的幂次方有关。假如HashCode的倒数第二第三位从0变成了1，但是运算的结果都是1001。也就是说，当HashMap长度为10的时候，有些index结果的出现几率会更大，而有些index结果永远不会出现（比如0111）！ 这样，显然不符合Hash算法均匀分布的原则。 反观长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的 处理散列表中的碰撞冲突我们在每个bucket数组中都以链表或者红黑树的数据结构存放。在同一个bucket中存放的数据量较少的时候，我们会采用链表的结构存放，在数据量较大时，会采用红黑树的数据结构存放。 HashMap中hash算法中几个问题12345// 重新计算hash值 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 12//计算Hash数组中bucket位置(n - 1) &amp; hash 这个哈希算法中： ^ 表示按异或运算，只要位不同就为1，不然为0 &gt;&gt;&gt;无符号右移，右边补0 为什么要用无符号右移16位后做异或运算的解答和为什么HashMap长度要是2的幂次方的长度这里有个非常好的解答 Hash算法的一些问题 HashMap和HashTable的区别HashTable和HashMap同样是基于哈希表实现的，同样每个元素都是一个key-value对，但是在解决链表冲突问题上，HashMap在JDK8.0上是使用单链表或者红黑树来解决的，而HashTable只使用单链表。 继承的父类不同HahshMap继承自AbstractMap类，而HashTable继承自Dictionary类，但是两者都实现了Map接口 线程安全性不同HashMap不是线程同步的 如果集合应用中不需要线程安全，那么推荐使用HashMap；如果需要高度的线程安全，那么推荐使用java.util.concurrentHashMap来代替HashTable。 key和value是否可以为空Hash值不同在HashTable的底层代码中，Hash值是直接使用对象的HashCode方法得出的，而HashMap则利用对象的HashCode方法重新计算了Hash值 Java中的Serialization机制和transient关键字简单来说，Java中的Serialization机制就是指类或者基本的数据类型持久化(persistence)到数据流中(Stream)中，包括文件、字节流、网络数据流。 Java中实现Serialiazation主要依靠两个类:ObjectOutputStream和ObjectInputStream。他们是JavaIO系统里OutputStream和InputStream的子类。既然他们是JavaIO的子类，那么就可以像操作流一样操作他们。 Java的Serialization机制 Java的关键字transient 静态内部类的加载时机 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。 实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。 直接调用静态内部类时，外部类不会加载","link":"/2020/03/03/%E7%90%86%E8%A7%A3HashMap/"},{"title":"读书路线","text":"个人列出有关自主学习路线要看的书籍，重点是基础知识必须先掌握好，并且在此之上，要求自己对于算法与编程实践概念掌握好。 算法与数据结构相关 大话数据结构 剑指offer 编程之美 编程珠玑 Java书籍推荐Java基础书籍推荐 Java 核心技术 初学Java者推荐这本书学习，内容详细而且精炼，阅读完这本书对于在阅读Java编程思想这本有着很大的帮助。 Java 编程思想 Java圣经级别的书籍，需要有一定的基础之后在细细品读这本书，对于Java的理解有很大的帮助 进阶书籍推荐Java的多线程，锁，虚拟机等知识 多线程编程 Java并发编程的艺术 Java多线程编程核心技术 Java虚拟机 深入理解Java虚拟机对于理解Java底层虚拟机有着很好的帮助，同时也在面试中占大头。 其他 函数式编程思想 计算机网络 TCP/IP详解 Java web及其框架 Spring实战 springMVC+MyBatis开发 快餐类的书籍，但对于初入门应用层框架有一定的帮助 spring技术内幕 中间件源码及架构学习 MySQL 《MySQL技术内幕 InnoDB存储引擎 第2版》 《高性能MySQL》 《MySQL45讲》 Redis 《Redis设计与实现》 Redis源码 Kafka《深入理解Kafka核心设计与实现原理》 分布式系统《数据密集型应用系统涉及》 Elastcsearch服务器开发 Java中间件Elasticsearch搜索引擎开发","link":"/2019/08/31/%E8%AF%BB%E4%B9%A6%E8%B7%AF%E7%BA%BF/"},{"title":"链表、栈与队列","text":"链表、栈和队列是最基础的数据结构，理解这些数据结构对解决算法帮助很大。 链表1234567891011public class Node { int value; Node next; public Node(int value){ this.value = value; } public Node() { }} 操作一个链表只需要知道它的头指针就可以做任何操作了 添加数据到链表中 遍历找到尾节点，插入即可(只要while(temp.next != null)，退出循环就会找到尾节点) 遍历链表 从首节点(有效节点)开始，只要不为null，就输出 给定位置插入节点到链表中 将原本由上一个节点的指向交由插入的节点来指向 上一个节点指针域指向想要插入的节点 首先判断该位置是否有效(在链表长度的范围内) 找到想要插入位置的上一个节点 获取链表的长度 每访问一次节点，变量++操作即可 删除给定位置的节点 将原本由上一个节点的指向后面一个节点 首先判断该位置是否有效(在链表长度的范围内) 找到想要插入位置的上一个节点 对链表进行排序 使用冒泡算法对其进行排序 找到链表中倒数第k个节点 设置两个指针p1、p2，让p2比p1快k个节点，同时向后遍历，当p2为空，则p1为倒数第k个节点 删除链表重复数据 操作跟冒泡排序差不多，只要它相等，就能删除了～ 查询链表的中间节点 这个算法也挺有趣的：一个每次走1步，一个每次走两步，走两步的遍历完，然后走一步的指针，那就是中间节点 递归从尾到头输出单链表 只要下面还有数据，那就往下找，递归是从最后往前翻。 反转链表 有递归和非递归两种方式。 栈栈的特性数据结构的栈长的是这个样子： 其实非常好理解，我们将栈可以看成一个箱子 往箱子里面放东西叫做入栈 往箱子里面取东西叫做出栈 箱子的底部叫做栈底 箱子的顶部叫做栈顶 说到栈的特性，肯定会有一句经典的言语来概括：先进后出(LIFO, Last In First Out) 往箱子里边放苹果，箱子底部的苹果想要拿出来，得先把箱子顶部的苹果取走才行 集合中的栈Stack集合类是继承Vector类的 主要有以下成员方法： 队列队列特性数据结构的队列长的是这个样子： 其实队列非常好理解，我们将队列可以看成小朋友排队 队尾的小朋友到指定的地点了–&gt;出队 有新的小朋友加入了–&gt;入队 相对于栈而言，队列的特性是：先进先出 先排队的小朋友肯定能先打到饭！ 队列也分成两种： 静态队列(数组实现) 动态队列(链表实现) 这次我就使用数组来实现静态队列了。值得注意的是：往往实现静态队列，我们都是做成循环队列 做成循环队列的好处是不浪费内存资源！ 集合中的队列集合中的队列分为单向队列和双向队列。实现的是接口形式： 单向队列集合的方法 双向队列集合的方法： 总结数据结构的栈和队列的应用非常非常的多，这里也只是最简单的入门，理解起来也不困难。 栈：先进后出 队列：先进先出","link":"/2020/03/03/%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"集合","slug":"集合","link":"/tags/%E9%9B%86%E5%90%88/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"}]}